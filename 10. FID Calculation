from scipy.linalg import sqrtm
import numpy as np

def calculate_fid(mu1, sigma1, mu2, sigma2):
    diff = mu1 - mu2
    covmean = sqrtm(sigma1.dot(sigma2))
    fid = diff.dot(diff) + np.trace(sigma1 + sigma2 - 2 * covmean)
    return np.real(fid)

mu1, sigma1 = np.random.rand(3), np.eye(3)
mu2, sigma2 = np.random.rand(3), np.eye(3)

print("FID Score:", calculate_fid(mu1, sigma1, mu2, sigma2))


THEORY -
theory of FID (FrÃ©chet Inception Distance)

1. FID is used to **measure the similarity between two sets of images** (usually real vs. generated).

2. It compares the **feature distributions** of both sets, not raw pixels.

3. For each set, features are modeled as a **multivariate Gaussian** with:

   * mean vector (Î¼)
   * covariance matrix (Î£)

4. The FID formula is:

   ```
   FID = ||Î¼1 - Î¼2||Â² + Tr(Î£1 + Î£2 - 2 * sqrt(Î£1 Î£2))
   ```

   * First term = distance between means.
   * Second term = difference in covariance (spread of features).

5. Lower FID â†’ generated images are closer to real ones.

6. Higher FID â†’ images look less realistic.

In your code:

* You created random means (`mu1, mu2`) and identity covariance matrices (`sigma1, sigma2`).
* `sqrtm` computes the matrix square root of the product of covariances.
* The function returns a real FID value (`np.real(fid)`).

ðŸ‘‰ This is a **toy example**. In practice, Î¼ and Î£ are computed from **Inception-v3 embeddings** of large image batches (real vs. generated).



* `from scipy.linalg import sqrtm` â†’ imports function to compute the square root of a matrix.

* `import numpy as np` â†’ imports NumPy for arrays and math operations.

* `def calculate_fid(mu1, sigma1, mu2, sigma2):` â†’ defines a function to calculate FID.

* `diff = mu1 - mu2` â†’ finds the difference between the two mean vectors.

* `covmean = sqrtm(sigma1.dot(sigma2))` â†’ multiplies two covariance matrices and computes their square root.

* `fid = diff.dot(diff) + np.trace(sigma1 + sigma2 - 2 * covmean)` â†’ calculates the FID formula using mean difference and covariance statistics.

* `return np.real(fid)` â†’ ensures the result is real (removes small imaginary values from computation).

* `mu1, sigma1 = np.random.rand(3), np.eye(3)` â†’ creates random mean (3D) and identity covariance for dataset 1.

* `mu2, sigma2 = np.random.rand(3), np.eye(3)` â†’ creates random mean and identity covariance for dataset 2.

* `print("FID Score:", calculate_fid(mu1, sigma1, mu2, sigma2))` â†’ calls the function and prints the FID score.



