import numpy as np
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt

# Generate synthetic data
data = np.random.randint(0, 255, (10, 5))
print("Original Data:\n", data)

# Scale data between 0 and 1
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data)
print("Scaled Data:\n", scaled_data)

THEORY -


### 1. Generative AI and Data Preprocessing

* Generative AI models (GANs, VAEs, Transformers, etc.) generate new data samples by learning patterns from training data.
* For these models, **preprocessing is critical** because raw data often has different scales, ranges, and formats.
* Normalization (scaling) ensures faster convergence, better stability, and prevents certain features from dominating others.

---

### 2. About the Code

* `numpy` creates synthetic data (like images or tabular values).
* `MinMaxScaler` from scikit-learn normalizes data values between 0 and 1.
* `matplotlib` can be used later for visualization (though in your code it’s not plotted yet).

---

### 3. Steps in Code Execution

1. **Synthetic Data Generation**

   ```python
   data = np.random.randint(0, 255, (10, 5))
   ```

   * Creates a 10×5 matrix with integer values between 0 and 255.
   * Mimics pixel values in an image dataset (since pixel intensity ranges from 0–255).

2. **Scaling (Normalization)**

   ```python
   scaler = MinMaxScaler()
   scaled_data = scaler.fit_transform(data)
   ```

   * Each feature (column) is scaled to the range \[0, 1].
   * Formula:

     $$
     X' = \frac{X - X_{\text{min}}}{X_{\text{max}} - X_{\text{min}}}
     $$
   * Example: if column values range between 50–200, then 50 → 0 and 200 → 1, with others mapped proportionally.

3. **Result**

   * Original data: different ranges (0–255).
   * Scaled data: all values compressed between 0 and 1.

---

### 4. Why Scaling is Important in Generative AI

* Ensures **numerical stability** (prevents exploding or vanishing gradients).
* Makes training **faster** and more accurate.
* Useful when input features have very different scales (e.g., age vs. income).
* Especially critical for **image generation**, where pixel intensities must be normalized (0–1 or -1–1).

---

### 5. Visualization Idea

You can plot before and after scaling:

```python
plt.subplot(1,2,1)
plt.title("Original Data")
plt.imshow(data, cmap='viridis')

plt.subplot(1,2,2)
plt.title("Scaled Data")
plt.imshow(scaled_data, cmap='viridis')

plt.show()
```
